#
#   Copyright 2020 Joshua Maglione 
#
#   Distributed under MIT License
#


from rationalPoints import _guess_polynomial
from globalVars import _DEFAULT_VERBOSE as _verbose

# A useful function for multiple lines
_cat_with_space = lambda x, y: x + "\n" + y

# Get the name of the atlas, which is the last folder of the directory.
def _get_atlas_name(A):
    direc = A.directory
    b = direc.rindex("/")
    if "/" in direc[:b]:
        a = direc[:b].rindex("/")
    else:
        a = -1
    return direc[a + 1:b]

# The preamble to the tex document containing all the stuff above 
# "\begin{document}."
def _preamble(title="", author=""):
    lines = [
        "\\documentclass[a4paper]{article}\n",
        "\\usepackage{enumerate}",
        "\\usepackage{hyperref}",
        "\\hypersetup{",
        "\tcolorlinks=true,",
        "\tlinkcolor=blue,",
        "\tfilecolor=blue,",
        "\turlcolor=blue,",
        "\tcitecolor=blue,",
        "}",
        "\\usepackage{amsmath}",
        "\\usepackage{amsthm}",
        "\\usepackage{amssymb}",
        "\\usepackage[margin=2cm]{geometry}",
        "\\usepackage{mathpazo}",
        "\\usepackage{url}",
        "\\usepackage[labelformat=simple]{subcaption}",
        "\\usepackage{tikz}",
        "\\usepackage{pgf}",
        "\\usepackage{longtable}",
        "\\usepackage{multirow}",
        "\\usepackage{graphicx}\n",
        "\\title{%s}" % (title),
        "\\author{%s}" % (author),
        "\\date{\\today}"
    ]
    return reduce(_cat_with_space, lines)
    
# The introduction of the tex document. 
def _intro(direc):
    sing_zeta = "\\textsf{SingularZeta}"
    direc_str = "\\texttt{%s}" % (direc)
    Fp = "$\\mathbb{F}_p$"
    intro = """
        This is a report generated by %s concerning the chart data in the 
        directory %s. We report all the computations we undertake in computing 
        the cone integral associated to %s. While this report is being 
        developed, we provide the table of varieties for which we need to count the number of %s-rational points. The rows with no entry under %s-points cannot be done automatically with the current implementation of %s. Special attention should be given to the ones with no %s-points if such examples arise. 
    """ % (
        sing_zeta, 
        direc_str,
        direc_str,
        Fp, 
        Fp,
        sing_zeta,
        Fp
    )
    return intro.replace("        ", "")

# Given a set of integers, return a latex compatible string for a set of 
# integers.
def _set_to_latex(S):
    content = reduce(lambda x, y: x + str(y) + ", ", S, "")
    return "$\\{" + content[:-2] + "\\}$"

# Format a polynomial to a latex compatible string.
def _format_poly(f):
    from sage.all import latex
    return "$%s$" % (latex(f))

# Convert the dictionary output by pRationalPorints into latex output.
def _poly_data_to_latex(P):
    from sage.all import latex
    system = P["simplified_system"]
    gens = P["simplified_ring"].gens()
    def _format_system(S):
        sys_str = map(lambda f: latex(f), S)
        poly_sys = reduce(lambda x, y: x + y + ",\\; ", sys_str, "$")
        return poly_sys[:-4] + "$"
    if len(system) <= 1:
        return _format_poly(system[0]), len(gens)
    else:
        return _format_system(system), len(gens)

# A function that returns the header for the F_p table of non-polynomial point 
# counts.
def _Fp_nonpoly_header(exists=False):
    Fp = "$\\mathbb{F}_p$"
    sing_zeta = "\\textsf{SingularZeta}"
    header = """
        \\subsection{Varieties with non-polynomial %s-point counts}\n
    """ % (Fp)
    header.replace("        ", "")
    if exists:
        header += """
            We separate the table of varieties with %s-point count not obviously given by a polynomial. It is possible these varieties are given by a (uniform) polynomial, but %s could not guess this. 
        """ % (Fp, sing_zeta)
    else:
        header += """
            We guess that all varieties have an %s-point count that is given by a (uniform) polynomial, so we do not have a table for this section.
        """ % (Fp)
    return header.replace("            ", "")

# A function that returns the header for the F_p table concerning the guesses.
def _Fp_guess_header(exists=False):
    Fp = "$\\mathbb{F}_p$"
    header = """
        \\subsection{Varieties with estimated %s-point counts}\n
    """ % (Fp)
    header.replace("        ", "")
    if exists:
        header += """
            We include the table of varieties which we could not explicitly determine the polynomials for the number of %s-points. However, we explicitly computed the counts for an overfit set of primes, so we expect these polynomials to be correct for all but finitely many primes.
        """ % (Fp)
    else:
        header += """
            We were not able to guess any of the %s-point counts for the varieties in this atlas. 
        """ % (Fp)
    return header.replace("            ", "")

# A function that returns the header for the entire F_p table.
def _Fp_table_header():
    Fp = "$\\mathbb{F}_p$"
    header = """
        \\subsection{The %s-point counts for all varieties}

        We write all the varieties for all the monomial cone integrals in one 
        table. 
    """ % (Fp)
    return header.replace("        ", "")

# A function to build the F_p-table of the varieties with non-polynomial 
# Fp-point counts as a latex compatible string.
def _build_nonpoly_Fp_table(chrts):
    table_top = [
        "\\begin{center}",
        "\t\\begin{longtable}{|c|c|p{6cm}|c|c|}",
        "\t\t\\hline",
        "\t\t\\textbf{Chart} & " +
            "\\textbf{Vertex} & " + 
            "\\textbf{Variety} & " + 
            "\\textbf{Dim.}\\\\ \\hline \\hline" 
    ]
    table_end = [
        "\t\\end{longtable}",
        "\\end{center}"
    ]

    # The main function we apply to all charts.
    def extraction(C):
        ID = C._id
        V = C.intLat.vertices
        Fp = C.intLat.pRationalPoints()
        data = zip(V, Fp)

        def get_info(X):
            info = "\t\t%s & %s & " % (ID, _set_to_latex(X[0]))
            info += "%s & %s" % (_poly_data_to_latex(X[1][1]))
            if not "C" in str(X[1][0]):
                return ""
            info += " \\\\ \\hline"
            return info

        chart_section = filter(lambda l: l != "", map(get_info, data))
        if len(chart_section) == 0: 
            return [""]
        chart_section[-1] = chart_section[-1] + " \\hline"
        return chart_section

    # Get all the chart data from extraction, and flatten it down.
    table_main = reduce(lambda x, y: x + y, map(extraction, chrts))
    table = table_top + table_main + table_end
    return reduce(_cat_with_space, table)

# A function to build the F_p-table of the varieties where we guessed the 
# Fp-point count with polynomials. 
def _build_estimate_Fp_table(chrts):
    table_top = [
        "\\begin{center}",
        "\t\\begin{longtable}{|c|c|p{6cm}|c|c|c|}",
        "\t\t\\hline",
        "\t\t\\textbf{Chart} & " +
            "\\textbf{Vertex} & " + 
            "\\textbf{Variety} & " + 
            "\\textbf{Dim.} & " + 
            "\\textbf{Guess}\\\\ \\hline \\hline" 
    ]
    table_end = [
        "\t\\end{longtable}",
        "\\end{center}"
    ]

    # The main function we apply to all charts.
    def extraction(C):
        ID = C._id
        V = C.intLat.vertices
        Fp = C.intLat.pRationalPoints()
        data = zip(V, Fp)

        def get_info(X):
            info = "\t\t%s & %s & " % (ID, _set_to_latex(X[0]))
            info += "%s & %s & " % (_poly_data_to_latex(X[1][1]))
            if "X" in str(X[1][0]):
                info += "{\\footnotesize " + _format_poly(X[1][0]) + "}"
            else: 
                return ""
            info += " \\\\ \\hline"
            return info

        chart_section = filter(lambda l: l != "", map(get_info, data))
        if len(chart_section) == 0: 
            return [""]
        chart_section[-1] = chart_section[-1] + " \\hline"
        return chart_section

    # Get all the chart data from extraction, and flatten it down.
    table_main = reduce(lambda x, y: x + y, map(extraction, chrts))
    table = table_top + table_main + table_end
    return reduce(_cat_with_space, table)

# A function to build the entire F_p-table as a latex compatible string.
def _build_Fp_table(A):
    Fp = "$\\mathbb{F}_p$"
    table_top = [
        "\\begin{center}",
        "\t\\begin{longtable}{|c|c|p{6cm}|c|c|c|}",
        "\t\t\\hline",
        "\t\t\\textbf{Chart} & " +
            "\\textbf{Vertex} & " + 
            "\\textbf{Variety} & " + 
            "\\textbf{Dim.}\\ & " + 
            "%s-\\textbf{points}\\\\ \\hline \\hline" % (Fp)
    ]
    table_end = [
        "\t\\end{longtable}",
        "\\end{center}"
    ]

    # The main function we apply to all charts.
    def extraction(C):
        ID = C._id
        V = C.intLat.vertices
        Fp = C.intLat.pRationalPoints()
        data = zip(V, Fp)

        def get_info(X):
            info = "\t\t%s & %s & " % (ID, _set_to_latex(X[0]))
            info += "%s & %s & " % (_poly_data_to_latex(X[1][1]))
            if not "C" in str(X[1][0]):
                info += "{\\footnotesize " + _format_poly(X[1][0]) + "}"
            else: 
                # is_poly, f = _guess_polynomial(X[1][1]["simplified_ring"], X[1][1]["simplified_system"])
                # if is_poly:
                #     info += "{\\footnotesize " + _format_poly(f) + "}"
                # else:
                info += "{\\tiny NOT POLYNOMIAL}"
            info += " \\\\ \\hline"
            return info

        chart_section = map(get_info, data)
        chart_section[-1] = chart_section[-1] + " \\hline"
        return chart_section

    # Get all the chart data from extraction, and flatten it down.
    table_main = reduce(lambda x, y: x + y, map(extraction, A.charts))
    # Put everything together and return a string.
    table = table_top + table_main + table_end
    return reduce(_cat_with_space, table)


# ==============================================================================
#   Main function
# ==============================================================================

# The following is a function that outputs a tex file. The tex file provides 
# information concerning the polynomials associated to the atlas A for which we 
# cannot automatically determine the number of F_p-rational points. 
def Report(A, file=""): 
    # Take care of input
    if not isinstance(file, str):
        raise TypeError("Expected 'file' to be a string.")

    # Make sure the file string is formatted correctly.
    atlas_name = _get_atlas_name(A)
    if file == "":
        file = atlas_name + "Report.tex"
    if not ".tex" in file:
        file_name = file + ".tex"
    else:
        file_name = file
    atlas_name_latex = atlas_name.replace("_", "\\_")

    title = "Report for %s" % (atlas_name_latex)
    with open(file_name, 'w') as tex_file:
        tex_file.write(_preamble(title=title))
        tex_file.write("\n\n\\begin{document}")
        tex_file.write("\n\n\\maketitle")
        tex_file.write("\n\\tableofcontents\n\n")
        tex_file.write("\n\n\\section{Introduction}\n\n")
        tex_file.write(_intro(atlas_name_latex))
    
    with open(file_name, 'a') as tex_file:
        tex_file.write("\n\n\\section{Counting $\\mathbb{F}_p$-points}")

    # Determine the F_p-rational points of the atlas. 
    # These are stored with the intersection lattices.
    # If these were previously computed, then nothing happens here.
    _ = map(lambda C: C.intLat.pRationalPoints(user_input=False), A.charts)

    # Get the charts with a vertex with non-polynomial point count. 
    def nonpoly(C):
        Fp_counts = C.intLat.pRationalPoints()
        counts = list(map(lambda X: X[0], Fp_counts))
        return filter(lambda x: "C" in str(x), counts) != []
    nonpoly_chrts = list(filter(nonpoly, A.charts))

    if _verbose >= 1:
        print "Guessing polynomial Fp-point counts."

    nonpoly_exists = False
    guess_exists = False
    # A function we apply to the nonpoly charts. If it guesses a poly it will 
    # replace the non-guess with a polynomial in X.
    def guess_chart(C): 
        Fp_points = C.intLat.pRationalPoints()
        def guess_func(data):
            if "C" in str(data[0]):
                is_poly, f = _guess_polynomial(data[1]["simplified_ring"], 
                data[1]["simplified_system"])
                if is_poly:
                    guess_exists = True
                    return tuple([f, data[1]])
                nonpoly_exists = True
            return data
        C.intLat.p_points = map(guess_func, Fp_points)
        return C
    checked_chrts = map(guess_chart, nonpoly_chrts)

    # Build the non-polynomial table
    nonpoly_table = _build_nonpoly_Fp_table(checked_chrts)
    # Build the estimate table 
    estimate_table = _build_estimate_Fp_table(checked_chrts)
    # Build the entire table
    table = _build_Fp_table(A)

    with open(file_name, 'a') as tex_file:
        tex_file.write("\n\n" + _Fp_nonpoly_header(exists=nonpoly_exists))
        tex_file.write("\n\n" + nonpoly_table + "\n\n")
        tex_file.write("\n\n" + _Fp_guess_header(exists=guess_exists))
        tex_file.write("\n\n" + estimate_table + "\n\n")
        tex_file.write("\n\n" + _Fp_table_header())
        tex_file.write("\n\n" + table + "\n\n")

    with open(file_name, 'a') as tex_file:
        tex_file.write("\n\n\\end{document}")

    return 